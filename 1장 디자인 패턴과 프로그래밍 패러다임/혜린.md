# 면접을 위한 CS 전공지식 노트

# 1. 디자인 패턴과 프로그래밍 패러다임

- 라이브러리: 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것. 프레임워크에 비해 자유로움
- 프레임워크: 공통으로 사용될 수 있는 특정한 기능들을 모듈화 한 것. 라이브러리에 비해 좀 더 엄격하다.

## 1.1 디자인 패턴

디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있또록 하나의 ‘규약’ 형태로 만들어 놓은 것

### 싱글톤 패턴(singleton pattern)

> 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
> 
- 장점
    - 매번 인스턴스를 생성하는 것이 아니라 참조하는 방식이기 때문에 많은 메모리 공간을 절약할 수 있다.
- 단점
    - 단위 테스트가 어렵다. 미리 생성된 하나의 인스턴스를 기반으로 구현하기 때문에 각 테스트 마다 ‘독립적인’ 인스턴스를 만들기 어렵기 때문이다.
    - 의존성이 높아진다. 실수로 Singleton 클래스를 수정하면 애플리케이션 전체에 수정된 값이 공유되기 때문에 예기치 않은 동작이 발생할 수 있다.

❓ **리액트의 상태관리**

리액트에서의 싱글톤 패턴은 상태관리 라이브러리에서 찾을 수 있다.

예를 들어, `Redux` 라이브러리에서는 `store` 객체를 생성할 때 싱글톤 패턴을 기반으로 활용하게 된다. 

`store` 객체는 애플리케이션의 상태를 관리하고, 상태가 변경될 때마다 `subscribe` 함수를 호출하여 등록된 콜백 함수를 실행시킨다. 

이 때, `store` 객체는 전역으로 사용되며, 하나의 인스턴스만 생성되도록 구현된다.

### 팩토리 패턴

> 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴
> 

쉽게말해 부모 클래스에서 자식 객체를 생성하는데, 그 객체의 유형을 다양하게 할 수 있는 것을 말한다.

같은 맥락을 갖는 행위들이 각 구현에서 팩토리를 통해 제공되기 때문에 수정사항이 발생했을 때 수정 할 범위가 줄어든다.

```jsx
class Superman {
  name;
  constructor() {
    this.name = "Superman";
  }
}
 
class Batman {
  name;
  constructor() {
    this.name = "Batman";
  }
}
 
class Pororo {
  name;
  constructor() {
    this.name = "Pororo";
  }
}
 
class Person {
  name;
 
  constructor(name) {
    let person;
    if (name === "superman") {
      person = new Superman();
    } else if (name === "batman") {
      person = new Batman();
    } else if (name === "pororo") {
      person = new Pororo();
    }
    this.name = person.name;
  }
 
  sayHello() {
    console.log("Hello, " + this.name);
  }
}
 
const hero = new Person("superman");
hero.sayHello(); // Hello, Superman
```

Superman, Batman, proro 세 개의 객체가 있고 Person 객체에서 name을 받아서 이름에 맞는 객체를 선언하고 있다.

이렇게 되면 객체 생성 부분하고 Person 클래스의 로직 부분하고 함께 있게 되는데, 생성자 ``안에 객체를 생성하는 부분을 따로 빼서 구현하면 아래와 같다.

```jsx
class Superman {
  name;
  constructor() {
    this.name = "Superman";
  }
}
 
class Batman {
  name;
  constructor() {
    this.name = "Batman";
  }
}
 
class Pororo {
  name;
  constructor() {
    this.name = "Pororo";
  }
}
 
class PersonFactory {
  static getInstance(name) {
    const heroMap = {
      superman: Superman,
      batman: Batman,
      pororo: Pororo
    };
    return heroMap[name];
  }
}
 
class Person {
  name;
 
  constructor(name) {
    let hero = PersonFactory.getInstance(name);
    this.name = hero.name;
  }
 
  sayHello() {
    console.log("Hello, " + this.name);
  }
}
 
const hero = new Person("superman");
hero.sayHello(); // Hello, Superman

```

Person 함수에서 Superman, Batman, Pororo 객체를 선언하는 부분을 제외하고 PersonFactory를 만들었다.

이제 객체를 선언하는 부분은 PersonFactory로 모두 이동하였으며 Person에서 해당 클래스의 로직만 구현하면 되고 객체를 선언하는 부분은 PersonFactory로 분리시켰다. 따라서 각 클래스마다 기능과 객체 생성 부분을 구분할 수 있게 된다.

### 전략 패턴

> 정책 패턴이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴
> 

### 옵저버 패턴

> 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴
> 

여기서 주체란 객체의 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들을 의미한다.

이 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC 패턴에도 사용된다.

### **자바스크립트에서의 옵저버 패턴**

프록시 객체를 통해 구현할 수 있다.

**프록시(proxy) 객체**란 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회 등)의 작업을 가로챌 수 잇는 객체를 뜻하며 JS에서 프록시 객체는 두 개의 매개변수를 가진다

- target: 프록시 할 대상
- handler: 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수

### 프록시 패턴과 프록시 서버

프록시 객체는 디자인 객체 중 하나인 프록시 패턴이 녹아들어 있는 객체이다

### 프록시 패턴

> 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
> 

이를 통해 객체의 속성, 변환 등을 보완하며 보완, 데이터 검증, 캐싱, 로깅에 사용한다.

### 프록시 서버

> 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램
> 

**프록시 서버로 쓰는 ngix** 

비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버. 주로 Node.js 서버 앞단의 프록시 서버로 활용된다.

- 버퍼 오버플로우: 버퍼에 데이터를 쓰는 소프트웨어가 버퍼의 용량을 초과하여 인접한 메모리 위치를 덮어쓸 때 발생하는 비정상적인 현상이다.  공간이 충분하지 않은 컨테이너에 너무 많은 정보가 전달되어 결국 해당 정보가 인접한 컨테이너의 데이터를 대체하게 되는 것이다.

**프록시 서버로 쓰는 CloudFlare**

CloudFlare는 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스이다.

CDN 말고도 CloudFlare를 통해 누릴 수 있는 이점은 DDOS 공격 방어, HTTPS 구축이 있다. 이 모든 것은 웹 서버 앞단에 두어 ‘프록시 서버’로 쓰기 때문에 가능한 것이다.

- **CDN**
각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말한다. 사용자가 웹 서버로부터 콘텐츠를 다운로드 하는 시간을 줄일 수 있다.

**CORS와 프런트엔드의 프록시 서버**

CORS는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.

- **오리진**
    
    프로토콜과 호스트 이름, 포트의 조합을 말한다. 
    

### 이터레이터 패턴

> 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴
> 

순회할 수 있는 여러가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능하다.

- 이터레이터 프로토콜
    
    이터러블한 객체들을 순회할 때 쓰이는 규칙
    
- 이터러블한 객체
    
    반복 가능한 객체로 배열을 일반화 한 객체
    

### 노출모듈 패턴

> 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴
> 

아래 코드는 단점은 누군가 고의적으로 x와 y를 바꿀 수 있다. 코드 밑에 스크립트를 추가해서요. obj를 통째로 바꾸지 않더라도 밑에 `obj.x = 'hacked';` 라고 한 줄 추가만 하면 `obj.y();`를 했을 시 local 대신 hacked가 alert된다. 

```jsx
var obj = {
  x: 'local',
  y: function() {
    alert(this.x);
  }
}
```


![https://www.cloudflare.com/img/learning/security/threats/buffer-overflow/buffer-overflow-example.svg](https://www.cloudflare.com/img/learning/security/threats/buffer-overflow/buffer-overflow-example.svg)

이것을 방지하려면 아래처럼 함수로 감싼 후 return을 통해 공개할 변수(y)만 공개하고 비공개할 변수(x)는 비공개하는 방법을 취할 수 있다. 즉, return하는 변수는 공개 변수고, 다른 것은 비공개 변수인 것이다.

```jsx
var another = function () {
  var x = 'local';
  function y() {
    alert(x);
  }
  return { y: y };
}
var newScope = another();
```

### MVC 패턴

> 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴
> 

재사용성과 확장성이 용이하다. 그러나 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해진다.

**모델(Model)**

애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻한다. 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신한다.

**뷰(View)**

inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타낸다. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 말한다. 변경이 일어나면 컨트롤러에 이를 전달해야 한다.

**컨트롤러(Controller)**

하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다. 또한 모델과 뷰의 생명주기도 관리한다.

MV 패턴을 이용한 대표적인 라이브러리는 리액트(React.js)-가 있다.

### MVP 패턴

> MVC 패턴으로부터 파생되었으며 컨트롤러(C)가 프레젠터로 교체된 패턴
> 

뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌다.

### MVVM 패턴

> MVC의 컨트롤러가 뷰모델로 바뀐 패턴
> 

뷰모델은 뷰를 더 추상화한 계층이며, MVC 패턴과 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징이다.

뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지운하고 UI를 별도의 코드 수정없이 재사용 가능하며 단위 테스팅이 쉽다.

대표적인 라이브러리는 뷰(Vue.js)이다.

- 커맨드: 여러가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
- 데이터 바인딩: 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경된다.

## 1.2 프로그래밍 패러다임

> 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론
> 

프로그래밍 패러다임은 크게 선언형, 명령형으로 나뉜다. 선언형은 함수형이라는 하위 집합을 갖고 명령형은 객체 지향, 절차 지향으로 나뉜다.

선언형 프로그래밍이란 ‘무엇을’ 풀어내는가에 집중한다. 또한 **프로그램은 함수로 이루어진 것이다**라는 명제가 담겨있는 패러다임이다.

1. 함수형 프로그래밍

순수 함수로 로직을 구현하고 고차 함수로 재사용성을 높인 패러다임이다. 자바스크립트는 함수형 프로그래밍 방식이 선호된다.

**순수 함수**

출력이 입력에만 의존하는 것을 의미한다.

**고차 함수**

함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것을 의미한다.

**일급 객체**

고차 함수를 사용하기 위해서는 해당 언어가 일급객체여야 한다. 특징은 다음과 같다.

- 변수나 메서드에 함수를 할당할 수 있다.
- 함수 안에 함수를 매개변수로 담을 수 있다.
- 함수가 함수를 반환할 수 있다.

## 1.2.2 객체지향 프로그래밍

> 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식
> 

설계에 많은 시간이 소요되며 처리 속도가 타 프로그래밍 패러다임에 비해 상대적으로 느리다.

**객체 지향 프로그래밍의 특징**

- 추상화
    - 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 의미한다.
- 캡슐화
    - 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 말한다.
- 상속성
    - 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것을 말한다.
- 다형성
    - 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말한다.
        - 오버로딩: 같은 이름을 가진 메서드를 여러 개 두는 것을 말한다.
        - 오버라이딩: 주로 메서드 오버라이딩을 말하며 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것을 의미한다.

**설계 원칙**

- 단일 책임 원칙: 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙이다.
- 개방-폐쇄 원칙: 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 하는 원칙이다.
- 리스코프 치환 원칙: 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것을 의미한다.
- 인터페이스 분리 원칙: 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙을 말한다.
- 의존 역전 원칙: 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙을 말한다.

## 1.2.3 절차형 프로그래밍

> 로직이 수행되어야 할 연속적인 계산 과정으로 이뤄진다.
> 

단지 코드를 구현하기만 되기 때문에 가독성이 좋고 실행속도가 빠르다. 반면 모듈화가 어렵고 유지 보수성이 떨어진다.

## 1.2.4 패러다임의 혼합

가장 좋은 패러다임이라는 것은 없다. 비즈니스 로직이나 서비스의 특징을 고려해서 패러다임을 정하는 것이 좋다.
