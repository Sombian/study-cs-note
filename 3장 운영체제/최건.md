# 3장

## OS

운영체제(Operating System)는 사용자가 컴퓨터를 쉽게 다룰 수 있도록 해주는 인터페이스이다. OS와 유사하지만 소프트웨어를 추가로 설치할 수 없는 것을 펌웨어(firmware)라고 한다.

### OS의 역할

1. 자원 관리
2. 자원 보호
3. 하드웨어 인터페이스 제공
4. 소프트웨어 인터페이스 제공

### OS의 구조

```js
응용 프로그램
{
	<...>,
}
/* OS 시작 */
인터페이스
{
	GUI,
	CLI,
}
시스템 호출
{
	커널
	{
		드라이버,
	}
}
/* OS 끝 */
하드웨어
{
	<...>,
}
```

#### 드라이버

하드웨어를 제어하는 소프트웨어이다.

#### 시스템 호출

OS가 제공하는 커널 영역의 인터페이스이다.
->
OS는 직접적으로 커널 영역을 노출시키지 않고 시스템 호출이라는 추상화 계층을 통해 기능을 제공한다.
->
OS는 modebit(0=커널 모드, 1=유저 모드)을 통해 유저 모드와 커널 모드를 구분한다. 즉 일종의 flag이다.

## CPU

CPU(Central Processing Unit)는 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치이다.

### 산술논리연산장치

산술논리연산장치(ALU, Arithmetic Logic Unit)는 두개의 입력 신호를 받아서 덧셈, 뺄셈, 곱셈, 나누셈 등의 산술 연산과, AND, OR, NOT 등의 논리 연산을 처리한다.

### 제어장치

제어장치(CU, Control Unit)는 입력장치에서 전달받은 명령어를 해독하여 CPU 내부의 작업을 총괄하고 각 과정을 통제한다.

### 레지스터

레지스터(register)는 CPU에 내장되어있는 소규모의 초고속 임시기억장치이다.
->
CPU는 자체적으로 데이터를 저장할 수 있는 기능이 없기에 레지스터를 통해 데이터를 전달한다.

### 인터럽트

인터럽트(interrupt)는 예기치 않은 상황이 발생할 경우, 현재 실행중인 작업을 일시 중단하는 것이다. CPU는 인터럽트가 발생할 경우, 해당 상황을 우선 처리한 후, 실행중이던 작업으로 복귀하여 마저 처리한다.

#### 하드웨어 인터럽트

외부 입출력 장치(모니터, 마우스, 키보드, etc)에서 발생하는 외부 I/O 인터럽트, CPU 자신이 발생시키는 내부 인터럽트로 구분된다.

#### 소프트웨어 인터럽트

유저 모드에서 실행되는 응용 프로그램에서 발생하는 인터럽트이며, 트랩(trap)이라고도 부른다.

e.g
1을 0으로 나누는 경우,
존재하지 않는 메모리 주소에 접근하는 경우,

### DMA 컨트롤러

DMA 컨트롤러는 I/O 장치가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치이다.

### 메모리

메모리(memory)는 전자회로에서 임시 또는 영구적으로 이진값을 기억하는 장치이다.

e.g.
ROM(Read Only Memory)
RAM(Random Access Memory)

### 타이머

타이머(timer)는 CPU를 특정 프로그램이 독점하는 것을 차단하기 위해 일정 시간 이후에 OS에 제어권이 넘어가도록 인터럽트를 발생시킨다.

### 디바이스 컨트롤러

디바이스 컨트롤러(device controller)는 컴퓨터와 연결되어 있는 I/O 장치들의 일종의 작은 CPU로, 각 장치는 local buffer라고 부르는 임시기억 장치를 가진다.

---

## 메모리 계층

메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성된다.

### 레지스터

레지스터(register)는 CPU 내부에 있는 용량이 작은 휘발성/초고속 메모리이다.

### 캐시

캐시(cache)는 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위해 값을 미리 복사해 놓는 임시저장장치이다. 재연산하는 시간을 최소화하기 위해 사용한다.

#### 시간 지역성

시간 지역성(temporal locality)는 최근 사용한 데이터에 다시 접근하려는 특성을 뜻한다.

#### 공간 지역성

공간 지역성(spatial locality)는 최근 접근한 데이터를 이루고 있는 공간이나 그에 인접한 공간에 접근하는 특성을 뜻한다.

#### 캐시 히트

캐시 히트(cache hit)는 캐시에서 원하는 값을 찾았을 때를 뜻한다.
->
캐시 히트가 발생하면 해당 값을 제어장치를 거쳐 가져온다. 물리적 위치가 가깝고 CPU 내부 버스(bus)를 기반으로 작동하기에 속도가 빠르다.

#### 캐시 미스

캐시 미스(cache miss)는 캐시에서 원하는 값을 찾지 못했을 때를 뜻한다.
->
캐시 미스가 발생하면 해당 값을 메모리에서 가져온다. 물리적 위치가 멀고 시스템 버스(bus)를 기반으로 작동하기에 속도가 느리다.

#### 캐시 매핑

캐시 매핑(cache mapping)은 캐시가 히트되기 위해 매핑하는 방법을 뜻한다.

##### 직접 매핑

직접 매핑(direct mapping)은 모듈러 나머지 연산을 사용해 특정 메모리를 특정 캐시 주소에만 매핑하는 방식이다. 구현이 단순하고 접근속도가 빠르지만 교체가 자주 일어날 경우 적중률이 매우 낮다.

##### 연관 매핑

연관 매핑(associative mapping)은 순서를 일치시키지 않고 관련있는 캐시와 메모리를 매핑하는 방식이다. 적중률이 높지만 모든 블록을 탐색해야하기에 속도가 느리다.

##### 집합 연관 매핑

집합 연관 매핑(set associative mapping)은 직접 매핑과 연관 매핑의 절충안이다. 메모리를 일정한 집합으로 분리하고, 각 집합 자체는 직접 매핑을, 집합 내부에서는 연관 매핑을 사용하는 방식이다.

## 메모리 관리

자원(메모리)관리는 OS의 대표적인 기능중 하나이다.

### 가상 메모리

가상 메모리(virtual memory)는 메모리 관리 기법의 하나로, 프로세스간 메모리 영역 침범 문제 및 메모리 용량 부족 문제를 해결하기 위해 각 프로그램이 별도의 메모리를 독점하는 것처럼 가상화한 메모리이다.

이때 주어지는 주소를 가상 주소(logical address)라고 하며, 실제 메모리상에 있는 주소를 실제 주소(physical address)라고 한다.

가상 주소는 메모리관리장치(MMU)를 통해 실제 주소로 변환되기에 사용자는 실제 주소를 의식할 필요 없이 프로그램을 작성 가능하다.

가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 '페이지 테이블'로 관리된다. 이때 속도 향상을 위해 TLB를 사용한다.

#### 페이지

페이지(page)는 가상 메모리를 사용하는 최소 크기 단위이다.

#### 프레임

프레임(frame)은 실제 메모리를 사용하는 최소 크기 단위이다.

#### 페이지 폴트

페이지 폴트(page fault)은 프로세스가 페이지가 실제 메모리(RAM)에는 없는 경우에 발생하는 인터럽트이다.

#### 스와핑

스와핑(swapping)은 페이지 폴트가 발생하면 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고, 하드디스크의 일부를 마치 메모리처럼 사용하는 기법이다.

#### 스레싱

스레싱(thrashing)은 메모리의 페이지 폴트 빈도가 너무 높아 작업이 멈춘 것 같은 상태를 뜻한다.

페이지 폴트가 발생하면 스와핑이 발생하며, 또한  CPU 이용률이 낮아진다. OS는 CPU 이용률이 낮으면, CPU가 한가하다고 판단해 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 적재한다. 이 같은 악순환이 스레싱이다.

##### 작업 세트

작업 세트(working set)는 프로세스의 과거 사용 이력인 지역성을 통해 페이지 집합을 만들어 미리 메모리에 적재하는 방식이다. 이를 통해 탐색 비용 및 스와핑을 줄일 수 있다.

##### PFF

PFF(Page Fault Frequency)는 페이지 폴트 빈도를 조절하는 방법으로, 상한선과 하한선을 만드는 방법이다.

## 메모리 할당

메모리 할당은 연속 할당, 불연속 할당으로 나뉜다.

### 홀

홀(hole)은 할당할 수 있는 메모리 공간이다.

### 내부 단편화

내부 단편화(internal fragmentation)은 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상이다.

### 외부 단편화

외부 단편화(external fragmentation)은 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상이다.

### 연속 할당

연속 할당은 메모리에 프로그램을 순차적으로, 그리고 연속적으로 할당하는 방식이다.

#### 고정 분할 방식

고정 분할 방식(fixed partition allocation)은 메모리를 미리 나누어 관리하는 방식으로, 내부 단편화가 발생한다.

#### 가변 분할 방식

가변 분할 방식(variable partition allocation)은 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나누어 관리하는 방식이다. 내부 단편화는 발생하지 않지만 외부 단편화는 발생할 수 있다. 최초 적합(first fit), 최적 적합(best fit), 최악적합(worst fit)의 방식들이 있다.

### 불연속 할당

불연속 할당은 현대 운영체제가 사용하는 방식이다.

#### 페이징

페이징(paging)은 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당하는 방식이다. 홀의 크기가 균일하지 않은 문제가 없지만 주소 변환이 복잡해진다.

#### 세그멘테이션

세그멘테이션(segmentation)은 페이지 단위가 아닌 의미 단위인 세그멘트(segment)로 분할하는 방식이다. 공유와 보안 측면에서 장점을 가지지만 홀 크기가 균일하지 않은 단점이 있다.

#### 페이지드 세그멘테이션

페이지드 세그멘테이션(paged segmentation)은 프로그램을 의미 단위인 세그멘트로 나눠 공유나 보안 측면에서 강점을 두고 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 방식이다.

## 페이지 교체 알고리즘

메모리는 한정되어 있기 때문에 잦은 스와핑이 발생한다. 스와핑은 최소한으로 발생하도록 설계되어야한다.

### 오프라인 알고리즘

오프라인 알고리즘(offline algorithm)은 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이며, 최상의 성능을 제공하지만 미래에 사용하는 프로세스는 알 수 없기에 구현은 불가능하다. 그러나 성능의 지표로서 다른 알고리즘과의 성능 비교에 대한 상한 기준을 제공한다.

### FIFO

FIFO(First In First Out)은 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법이다.

### LRU

LRU(Least Recently Used)는 참조가 가장 오래된 페이지를 교체하는 방식이다. 가장 오래된 것을 파악하기 위해 페이지마다 상태를 관리해야하는 단점이 있다.

### NUR

NUR(Not Used Recently)는 LRU에서 발전한 방식이다. clock 알고리즘이라고도 부르며, 시계 방향으로 페이지를 교체한다.

### LFU

LFU(Least Frequently Used)는 가장 참조 횟수가 적은 페이지를 교체하는 방식이다.

## 프로세스

프로세스(process)는 메모리에 적재되어있는 프로그램이다.

### 프로세스의 상태 값

- 생성 상태
- 대기 상태
- 대기 중단 상태
- 실행 상태
- 중단 상태
- 일시 중단 상태
- 종료 상태

### 프로세스의 메모리 구조

#### 동적 영역

- 힙(heap): 런타임에 크기가 결정된다
- 스택(stack): 컴파일 타임에 크기가 결정된다

#### 정적 영역

- 코드 영역(code segment): 실행 코드
- 데이터 영역(data segment): 전역/정적 변수

### PCB

PCB(Process Control Block)는 OS에서 생성한 프로세스에 대한 메타데이터(metadata)이다. 중요한 정보를 포함하기에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리된다.

### 멀티 프로세싱

멀티 프로세싱은 여러 개의 프로세스를 통해 병렬적으로 두 가지 이상의 일을 수행하는 것을 의미한다.

#### IPC

IPC(Inter Process Communication)는 프로세스간에 데이터를 교환하고, 공유 데이터를 관리하는 것을 의미한다.

e.g.
Client <-> Server

##### 공유 메모리

공유 메모리(shared memory)는 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어 프로세스가 서로 통신할 수 있는 메모리이다. 데이터를 복사하지 않기에 오버헤드가 발생하지 않아 속도가 가장 빠르지만 같은 메모리를 여러 프로세스가 공유하기에 동기화가 필요하다.

##### 파일

디스크 또는 서버에서 제공하는 데이터이다.

##### 소켓

네트워크 인터페이스(TCP, UDP)를 통해 전송하는 데이터이다.

##### 익명 파이프

익명 파이프(unnamed pipe)는 프로세스 간에 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로, 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동한다.

##### 명명 파이프

명명 파이프(named pipe)는 서버와 클라이언트의 통신을 위해 명명된 단방향 또는 양뱡향 파이프를 의미한다. 여러 파이프를 동시에 사용할 수 있다.

##### 메시지 큐

메시지 큐(message queue)는 메시지를 큐(queue) 자료구조로 관리하는 방식이다. 다른 IPC 방식에 비해서 사용 방법이 매우 직관적으로 간단하다.

#### 컨텍스트 스위칭

컨텍스트 스위칭(context switching)은 PCB를 기반으로 프로세스의 상태를 저장하고 불러오는 과정이다. (싱글 코어 기준) CPU는 언뜻 보면 병렬적으로 작업을 수행하는 것 처럼 보이지만 실제로는 시간을 매우 작게 분할해 각 작업을 빠르게 수행한다.
->
시분할(time-sharing)

### 스레드

스레드(thread)는 프로세스의 실행 가능한 가장 작은 단위이다. 각 프로세스는 복수의 스레드를 가질 수 있다.

#### 멀티스레딩

멀티스레딩은 프로세스의 작업을 여러 개의 스레드로 분할하여 처리하는 기법으로, 병목현상을 줄일 수 있다. 다만, 메모리를 공유하는 경우, 동시성 문제를 해결하기 위해 원자성(atomicity)를 보장하는 변수를 사용해야하며, 코드의 흐름 파악이 어렵다.

### 공유 자원

공유 자원(shared resource)은 각 프로세스 및 스레드가 접근할 수 있는 자원을 의미한다. 두개 이상의 프로세스에서 동시에 읽거나 쓰는 경우 경쟁 상태(race condition)이 발생할 수 있다.

### 임계 영역

임계 영역(critical section)은 둘 이상의 프로세스 및 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역을 의미한다. 이를 해결하기 위한 방법으로는 크게 뮤텍스, 모니터, 세마포어 세 가지가 있으며, 이 방법들 모두 상호 배제, 한정 대기, 융통성이라는 조건을 만족한다.

#### 뮤텍스

뮤텍스(mutex)는 프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 뒤에는 unlock()을 통해 잠금 해제하는 객체이다. 잠금이 설정되면 다른 프로세스나 스레드는 해당 자원에 접근할 수 없다.

#### 모니터

모니터(monitor)는 둘 이상의 스레드가 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대한 인터페이스만을 제공하는 방법이다. 모니터는 모니터큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리한다.

#### 세마포어

세마포어(semaphore)는 일반화된 뮤텍스이다. wait(), signal() 두가지 함수로 공유 자원에 대한 접근을 처리한다. wait()는 자신의 차례가 올 때까지 대기하는 함수이며, signal()은 다음 프로세스로 순서를 넘겨주는 함수이다.

### 교착 상태

교착 상태(deadlock)은 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 의미한다.

#### 교착 상태의 원인

- 상호 배제: 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능한 상태를 의미한다
- 점유 대기: 특정 프로세스가 점유한 자원을 프로세스가 요청하는 상태를 의미한다
- 환형 대기: 환형(cyclic)으로 서로가 서로의 자원을 요청하는 상태를 의미한다
- 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없는 것을 의미한다

## CPU 스케줄링 알고리즘

### 비선점형 방식

비선점형 방식(non-preemptive)은 프로세스가 스스로 CPU 소유권을 포기하는 방식으로, 강제로 프로세스를 중지하지 않는다. 컨텍스트 스위칭으로 인한 부하가 적다.

#### FCFC

FCFC(First Come, First Served)는 가장 먼저 온 것을 가장 먼저 처리하는 방식이다. 길게 수행되는 프로세스 때문에 준비 큐에서 오래 대기하는 현상(convoy effect)이 발생하는 단점이 있다.

#### SJF

SJF(Shortest Job First)는 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 알고리즘이다. 긴 시간을 프로세스가 실행되지 않는 현상(starvation)이 발생하며 평균 대시 시간이 가장 짧다. 실제로는 실행 시간을 알 수 없기 때문에 과거의 실핼했던 시간을 토대로 추축해서 사용한다.

### 선점형 방식

선점형 방식(preemptive)은 현대 운영체제가 사용하는 방식으로 지금 사용하는 프로세스를 알고리즘에 의해 중단시고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식이다.

### RR

라운드 로빈(RR, Round Robin)은 현대 컴퓨터가 사용하는 방식으로, 각 프로세스에 동일한 시간을 할당하고, 해당 시간 내에 작업이 끝나지 않으면 다시 준비 큐(ready queue)의 뒤로 이동키는 알고리즘이다.

### SRF

SRF(Shortest Remaining Time First)는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 일시 중단하고 해당 프로세스를 수행하는 알고리즘이다.
